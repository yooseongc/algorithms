
# B-Tree
 * 탐색은 큰 데이터 집합을 다룰 때 기초가 되는 연산이다.
 * 데이터를 어떻게 효율적으로 탐색할 것인가는 우리의 도전과제이다.
 * 이 절에서는 앞서 설명한 균형-트리 알고리즘을 더욱 확장하여, 메모리가 아닌 하드디스크나 웹에 심볼 테이블을 저장하여 훨씬 더 큰 규모의 외부 데이터를 대상으로 외부 탐색을 할 수 있게 한다.
 * 비용 모델
   * 데이터 스토리지 메커니즘은 매우 널리 사용되며 계속 진화하고 있다.
   * 여기서는 가장 핵심적인 부분만 반영한 단순한 모델을 사용하자.
   * 연속된 데이터 블록을 `페이지`라고 부르고, 그 페이지에 대한 첫 접근을 `탐지(probe)`라고 부르기로 하자.
   * 페이지에 대한 접근은 그 내용을 로컬 메모리로 옮기는 작업이 수반되는 것으로 가정한다.
   * 따라서 연이은 접근은 상대적으로 비싸지 않다.
   * 페이지 하나는 로컬 컴퓨터의 파일일 수도 있고 원격의 컴퓨터나 서버에 저장된 파일이 보이는 웹 페이지 일 수도 있고 무엇이든 가능하다.
   * 목표는 가능한 적은 수의 탐지만으로 주어진 키를 찾아내는 구현을 개발하는 것이다.
   * B-트리의 비용 모델 : 외부 탐색 알고리즘에서는 읽기/쓰기를 위해 페이지에 접근한 횟수를 헤아린다.
 * B-트리
   * 2-3 트리를 확장하되 데이터를 트리에 저장한느 것이 아니라 복제된 키들로 트리를 만들고 각 키가 링크와 연관되도록 한다.
   * 이러한 접근 방식은 마치 종이책 뒤의 색인처럼 인덱스와 테이블을 쉽게 분리할 수 있게 한다.
   * 2-3 트리에서 처럼 각 노드가 가질 수 있는 키-링크 쌍의 개수에 상하한을 둔다.
   * 이를 위해 파라미터 M(관례상 짝수)을 두어 다중 트리를 만들 때 모든 노드가 최대 M-1개(M-중 노드가 한 페이지에 표현될 만큼 M이 작다고 가정함.), 최소 M/2개(탐색 경로를 짧게 유지하도록 브랜칭을 유도함.)의 키-링크 쌍을 가지게 한다.
   * 단, 뿌리 노드는 예외로 M/2보다 적은 키-링크 쌍을 가질 수 있다. 단, 최소 2개는 가져야 한다.
   * 1970년대 베이어와 맥크레이트는 외부 탐색을 위한 다중 균형 트리를 처음 연구했고 이러한 트리를 B-트리라고 이름 지었다.
   * 이 책에서는 고정 크기 페이지를 사용하는 다중 균형 탐색 트리를 지칭하는 일반적인 이름으로서 B-트리를 사용하기로 한다.
   * M의 값을 지정할 때는 '오더 M B-트리'라고 부른다. 
   * 오더 4인 B-트리는 각 노드가 최대 3개, 최소 2개인 키-링크 쌍을 가지고, 오더 6인 B-트리는 최대 5개, 최소 3개인 키-링크 쌍을 가지는 식이다.
   * 뿌리 노드가 예외인 이유는 트리 생성 알고리즘을 살펴볼 때 분명해진다.
 * 관례
   * 기본 메커니즘을 설명하기 위해, Set의 구현(값은 없고 키만 있는 순차 버전)을 생각해본다.
   * 순차 심볼 테이블을 키와 값을 연관시키도록 확장해보면 이해에 도움이 된다.
   * 우리의 목적은 대규모 키 집합을 지원할 수 있는 add()와 contains() 메서드를 만드는 것이다.
   * 탐색 트리를 일반화하기 위해(순차, 비순차 모두 지원) 순서를 가진 키를 사용한다.
   * B-트리에서는 이를 위해 두 종류의 서로 다른 노드를 이용한다.
     * 내부 노드 : 키의 복제본과 페이지를 연관
     * 외부 노드 : 실제 데이터에 대한 참조 저장
   * 내부 노드의 모든 키는 다른 노드와 연관된다. 다른 노드는 해당 키와 같거나 큰 키들과, 다음번 큰 키(존재한다면)보다 작은 키들을 담고 있는 서브트리의 뿌리 노드이다.
   * 이 때 다른 모든 키보다 작은 특별한 키를 두면 편리해지는데, 이를 `보초(sentinel)`라고 부른다.
   * 뿌리 노드의 키 목록이 보초 키로 시작하도록 만들고, 탐색을 가이드하기 위해 보초 키의 복제본을 내부 노드에서 이용한다.
   * 이러한 관례들은 코드를 좀 더 단순하게 만든다.
   * 그리고 다른 탐색 트리에서 했었던 데이터와 링크를 뒤섞는 방식이 아닌 더 나은 대안을 보여준다.
 * 탐색과 삽입
   * B-트리에서의 탐색은 탐색 키를 가질 수 있는 유일한 서브트리로의 재귀적인 탐색을 기반으로 한다.
   * 모든 탐색은 키가 집합에 존재한다면 그 키를 가진 외부 노드에서 종료된다.
   * 내부 노드에서 탐색 키의 복제본을 만나는 경우에도 탐색 성공으로 종료할 수 있지만 항상 외부 노드까지 진행하고 나서 종료한다.
   * 왜나하면 그렇게 함으로써 순차 심볼 테이블 코드의 수정 작업을 단순화할 수 있다.
   * 구체적으로, 오더 6인 B-트리에서의 탐색을 생각해보자.
     * 이 B-트리는 3-노드, 4-노드, 5-노드들로 구성된다. 단 뿌리 노드는 2-노드일 수도 있다.
     * 탐색은 뿌리에서 시작하여 현재 노드에서의 탐색 키에 맞는 적절한 간격을 찾아 해당 링크를 통해 다음 노드로 이동한다.
     * 이러한 검색 과정으로 트리의 바닥에서 키가 속할 페이지에 이르게 된다.
     * 키가 페이지에 존재하면 탐색 성공, 존재하지 않으면 탐색 실패로 종료한다.
     * 2-3 트리에서와 마찬가지로 재귀적인 코드로 트리의 바닥에 새로운 키를 추가한다.
     * 만약 키를 저장할 공간이 없으면 바닥의 노드를 임시로 넘치는 상태가 되게 하고(6-노드) 재귀 호출 뒤에 트리를 거슬러 올라가면서 6-노드를 분할한다.
     * 만약 뿌리 노드가 6-노드이면 두 개의 3-노드에 연결된 2-노드로 분할한다.
     * 트리의 다른 부분들에서는 6-노드에 붙어 있는 k-노드를 2개의 3-노드에 붙어 있는 (k+1)-노드로 바꾼다.
     * 이 설명에서 3을 M/2로 바꾸고 6을 M으로 바꾸면 오더 M인 B-트리에서의 탐색과 삽입에 대한 설명이 된다.

> 정의 : 오더 M인 B-트리(M은 짝수)는 외부 k-노드(k개의 키와 연관 정보를 포함) 또는 내부 k-노드(k개의 키, 키들로 구분되는 k개 구간에 해당하는 B-트리로의 링크)로 
> 구성되는 트리로 다음과 같은 구조적인 속성을 갖는다. 뿌리에서 어떤 외부 노드로의 모든 경로는 반드시 같은 길이를 가진다(완전 균형). 그리고 
> 뿌리에서 k는 반드시 2에서 M-1 번위에 있어야 하고(B-트리가 공백인 경우 예외), 다른 노드들에서 k는 반드시 M/2에서 M-1 범위에 있어야 한다. 

 * 표현
   * B-트리 노드의 표현 방법에는 많은 선택권이 있다.
   * 이 부분은 페이지 API안에 추상화한다.
   * 페이지 API는 키와 페이지 객체로의 링크를 연관시키고 페이지의 오버플로, 분할, 내/외부 페이지 구분과 같은 작업들을 지원한다.
   * 페이지를 외부에 보관된(로컬 파일이나 웹사이트) 심볼 테이블로 생각할 수도 있다.
   * 페이지 API에서 열기(open)와 닫기(close)는 외부 페이지를 내부 메모리로 불러오거나 수정된 내용을 다시 내보내는(필요하다면)것을 지칭한다.
   * 내부 페이지에 대한 add() 메서드는 심볼 테이블 작업으로 주어진 페이지를 그 페이지를 뿌리로 하는 트리의 최소 키와 연관시킨다.
   * 외부 페이지를 위한 add()와 contains() 메서드는 외부 페이지에 연관된 SET 작업과 같다.
   * split() 메서드는 가장 많은 일을 하는데, 이 메서드는 용량이 찬 페이지에서 순위가 M/2보다 큰 M/2개의 키-값 쌍을 새로운 페이지로 분리하여 이동하고 새 페이지의 참조를 리턴한다.
   * 전형적인 실제 구현에서는 페이지의 읽고 쓰기를 위해 하드웨어 종속적인 코드가 사용된다.
 
```
public class Page<Key>

               Page(boolean bottom)       페이지 생성 및 열기
void           close()                    페이지 닫기
void           add(Key key)               (외부) 페이지에 키 추가
void           add(Page p)                p를 열고 이(내부) 페이지에 추가하여 p의 가장 작은 키와 p를 연관시키기
boolean        isExternal()               이 페이지는 외부 페이지인가?
boolean        contains(Key key)          key가 이 페이지에 존재하는가?
Page           next(Key key)              key를 가질 수 있는 서브트리
boolean        isFull()                   페이지가 가득 찼는가(오버플로)?
Page           split()                    키들 중 상위 절반을 새로운 페이지로 옮기기
Iterable<Key>  keys()                     페이지의 키들 순회하기
```

 * 위와 같은 준비를 바탕으로 만들어진 BTreeSet의 코드는 놀랍도록 단순하다.
 * contains() 메서드는 페이지를 인수로 받아 다음의 세 경우를 처리하면서 재귀적으로 동작한다.
   * 만약 페이지가 외부이고 키가 페이지에 존재한다면 true를 리턴한다.
   * 만약 페이지가 외부이고 키가 페이지에 존재하지 않는다면 false를 리턴한다.
   * 나머지의 경우, 키를 가질 수 있는 서브트리를 대상으로 재귀적으로 호출한다.
 * add() 메서드도 동일한 재귀 구조를 가진다. 단, 탐색하는 동안 키를 못 찾으면 바닥에 키를 추가하고, 노드가 오버플로된 경우 트리를 거슬러 올라가면서 분할을 한다는 것이 다르다.

```java
public class BTreeSet<Key extends Comparable<Key>> {
    
    private Page root = new Page(true);
    
    public BTreeSet(Key sentinel) {
        add(sentinel);
    }
    
    public boolean contains(Key key) {
        return contains(root, key);
    }
    
    private boolean contains(Page h, Key key) {
        if (h.isExternal()) return h.contains(key);
        return contains(h.next(key), key);
    }
    
    public void add(Key key) {
        add(root, key);
        if (root.isFull()) {
            Page leftHalf = root;
            Page rightHalf = root.split();
            root = new Page(false);
            root.add(leftHalf);
            root.add(rightHalf);
        }
    }
    
    public void add(Page h, Key key) {
        if (h.isExternal()) {
            h.add(key);
            return;
        }
        Page next = h.next(key);
        add(next, key);
        if (next.isFull()) h.add(next.split());
        next.close();
    }
}
```
 * 성능
   * B-트리의 가장 중요한 속성은 M 값이 적절하다면 모든 실질적인 응용에서 탐색 비용이 상수 시간이라는 점이다.
   * 전형적인 상황에서는 뿌리를 내부 메모리에 두어 탐지 비용을 1만큼 줄일 수 있다.
   * 디스크나 웹에서의 탐색을 할 때, 대량의 탐색 작업을 시작하기 전에 이러한 작업을 미리 해 둘 수 있다.
   * 뿌리 노드는 가장 빈번하게 접근되기 때문에 캐싱이 지원되는 가상 메모리 시스템이라면 자동으로 가장 빠른 메모리에 위치하게 될 것이다.
* 공간
   * B-트리의 공간 사용량은 실제 응용에서 중요한 관심사항이다.
   * B-트리는 생성 규칙에 의해 각 페이지의 최소한 절반은 채워진다.
   * 따라서 최악의 경우 실제 키의 개수에 비해 두 배 더 많은 공간을 소요할 수 있다.
   * 그리고 링크를 위한 공간이 추가적으로 쇼요된다.
   * 1979년 야오는 무작위 키 상황에서의 수학적 분석을 통해 노드 하나의 평균 키 개수가 Mln2임을 밝혔다.
   * 따라서 대략 44%에 달하는 공간이 사용되지 않는다. 

> 명제 B : N개의 항목을 가진 오더 M인 B-트리에서의 탐색 또는 삽입 작업은 log_M(N)에서 log_(M/2)(N)회에 이르는 탐지를 소요한다. 
> 이 값은 실제 응용에서 상수에 가깝다.
 * 증명
   * M개의 키로 가득 찬 노드를 나누면서 트리가 커 나가기(자식이 분할되면서) 때문에 트리 내부에 있는 모든 노드(뿌리 노드와 외부 노드가 아닌 노드)가 M/2에서 M-1 범위의 링크를 가진다.
   * 위 명제는 이 부분에서 유도된다.
   * 최적 조건에서 이 노드들은 가지 브랜치 비율이 M-1인 완전 트리가 된다. 이 경우 기술된 경계 값이 직접적으로 유도된다.
   * 최악 조건에서는 각각 차수 M/2인 완전 트리를 가리키는 항목 두 개가 뿌리 노드에 있게 된다. 밑이 M인 로그를 취하면 매우 작은 숫자가 얻어진다.
   * 가령 M이 1000이라면 625억 개보다 작은 N에서 트리의 높이가 4보다 작다. (~ 3.598)
 * 명제 B는 매우 중요한 결과로 고찰해 볼 가치가 있다.
 * 처리해야만 하는 상상 가능한 가장 큰 규모의 데이터가 있다고 하자.
 * 단지 4~5번의 탐지만으로 원하는 키를 찾아내고 삽입할 수 있는 알고리즘을 개발해 낼 수 있을까?
 * B-트리는 그러한 효율성을 달성해내기 때문에 널리 사용되고 있다.
 * 실제 응용에서는 B-트리 노드들이 차지하는 공간을 최소화하는 것이 도전적인 문제이다.
 * 그러나 대부분의 컴퓨팅 장치에서 저장 공간이 늘어나고 있기 때문에 점점 쉬운 문제가 되어가고 있다.
 * 기본 버전 B-트리는 목적에 따라 쉽게 변형된다.
   * 한 가지 변형은 가능한 많은 페이지 참조를 내부 노드에 욱여넣어 브랜치 비율을 높이고 트리를 평평하게 하는 것이다.
   * 또 다른 변형은 노드를 분할하기 전에 형제 노드와 병합하여 저장 공간 효율을 높이는 것이다.
 * 이러한 변형과 알고리즘의 파라미터를 특정 장치나 응용에 맞추어 최적화할 수 있다.
 * 비록 이러한 최적화가 작은 상수 비율의 개선에 지나지 않더라도 테이블이 대단이 크거나 많은 수의 트랜잭션이 이루어지는 경우 의미 있는 효과가 있을 수 있다.

